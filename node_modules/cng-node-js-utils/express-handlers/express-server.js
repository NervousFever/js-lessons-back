"use strict";

/**
 * 4.0 bổ sung hàm valid cors từ bên ngoài
 * 
 * Bổ sung 
 * req.logAccess(logType, req) với:
 * logType = 
 * 
 * HACKER : truy cập đường dẫn không có
 * | 
 * ERROR : lỗi hệ thống cần khắc phục trong code DEV chú ý việc này
 * | 
 * FAIL : truy cập bị cấm do các lỗi được khai báo trước
 * |
 * BLOCK : truy cập bị chặn do quét quá nhiều đường dẫn sai trong thời hạn định trước
 * |
 * CORS : cấm nguồn CORS
 * |
 * ACCESS : truy cập thành công
 * 
 *
 * if (typeof req.logAccess === "function") {
        try {
          // lưu log truy cập fail
          req.logAccess("HACKER", req);
        } catch { }
      }
 */

// các thành phần cho máy chủ nodejs
const {
  express,
  app,
  fs,
  os,
  CorsHandler,
  errors,
} = require("../express-util");
const arrObj = require("../array-object");
const secretUtil = require("../secret-util");

// nếu trong vòng 5 giây mà có ít nhất 2 lần truy cập bị sai thì block ngay ip này
//  thống kê các địa chỉ ip mà cố tình truy cập với thời lượng gần nhau với đường dẫn không có trong hệ thống
const failClient = new Map();
// ip là key và value là một object chứa số lượng thời hạn gần nhất đã truy cập sai, và số lượng truy cập sai tích lũy, và số lượng truy cập sai trong checkInterval giây gần đây
// nếu số lượng truy cập sai trong checkInterval gần đây vượt quá số lượng cho phép thì block không cho đi tiếp, và vẫn thống kê số lượng này
const MAX_BLOCK_INTERVAL = 60000;

// chạy vòng lặp định kỳ để xóa khỏi bộ nhớ user đăng ký
// 1 phút chạy một lần hoặc 30 giây
let intervalObj = setInterval(() => {
  // duyệt qua vòng lặp nếu quá thời gian thì xóa khỏi bộ nhớ
  for (const [ip, failAccess] of failClient.entries()) {
    // nếu quá hạn block thì xóa luôn để cho phép truy cập lại
    if (Date.now() - failAccess.blockTime > MAX_BLOCK_INTERVAL) {
      failClient.delete(ip);
    }
  }
}, 30000);

class ExpressServer {
  /**
     * Máy chủ cho phép khởi động theo cấu hình, khai Router, khai SocketIo nếu có
     * @param {*} expressCfg  = require("./cfg/express-server-easy-cfg");
     * Sử dụng phòng chống tấn công được cấu hình trước khi khai báo ở đây
     * @param {*} ddosUse     = require('./ddos/ddos-config').express('ip', 'path');
     // Khai báo apiRoutes để phục vụ các lệnh GET, POST cho đường dẫn API
     * @param {*} apiRoutes     = require("./routes")
     //--------- Khai báo máy chủ socket.io realtime ------------//
     // khai báo module socketio-server đã thiết lập sẵn cấu hình
     // let socketIo, socketCfg, SocketEventHandler;
     * @param {*} socketIoCfg   = const { socketIo, socketCfg, SocketEventHandler } = require('./server-socketio');
     * @param {*} failCfg   = { checkInterval: 5000,  maxCountFail4Block: 20 }; - sử dụng để hạn chế tấn công
     * @param {*} logViewer   = (req,res,next) - sử dụng để theo dõi các log hệ thống
     * @param {*} dynamicCors   = (req,res,next) - sử dụng để điều khiển cors nếu cần
     */
  constructor(expressCfg, ddosUse, apiRoutes, socketIoCfg, failCfg, logViewer, dynamicCors) {
    this.CFG = expressCfg;
    this.apiRoutes = apiRoutes;
    this.socketIoCfg = socketIoCfg;
    this.DDOS = ddosUse;
    this.LOGS = logViewer;
    this.CORS = dynamicCors;
    // khai báo điều khiển cors để lấy các tham số req. ... như sau:
    //paramS, ipClient, pathName, clientIp, clientDevice, method, origin, url
    this.corsHandler = new CorsHandler(
      this.CFG.domainIncludeCors || ["'localhost'"],
      this.CFG.isDebug
    );
    this.PORT = this.CFG.port || process.env.PORT || 5050;
    this.SUB_DIR = this.CFG.baseDirectory || "demo";
    this.REDIRECT_URL = this.CFG.redirectUrl || "/";

    this.failCfg = failCfg || {
      checkInterval: 1000, // trong thời gian kiểm tra này mà
      maxCountFail4Block: 10, // số lần gõ địa chỉ bị sai quá 20 lần sẽ bị block
    };
  }
  start() {
    // ------------------------Web tĩnh------------------------- //
    // client web demo cấp user login
    // đường dẫn gốc của trang web
    if (this.CFG.staticRoot) app.use(express.static(this.CFG.staticRoot));
    // đường dẫn phụ vào trong trang web html
    if (this.CFG.staticHtml)
      app.use(`${this.SUB_DIR}`, express.static(this.CFG.staticHtml));

    // --- sử dụng để khai báo hàm ghi log hệ thống, nhằm ghi lại quá trình truy cập, lỗi của hệ thống
    if (this.LOGS) app.use(this.LOGS);

    // ------------------------chống tấn công DDDOS------------------------- //
    // Ngăn chặn truy cập với tốc độ lớn làm nghẽn website này, vì năng lực có hạn
    if (this.DDOS) app.use(this.DDOS);

    // ------------------------Xử lý CORS------------------------- //
    // Xử lý CORS để lấy các tham số ứng dụng trong việc tiền xử lý trong API chính thức trả về req. gồm:
    // paramS, ipClient, pathName, clientIp, clientDevice, method, origin, url
    if (this.CORS) app.use(this.CORS);
    app.use(this.corsHandler.expressCors());

    // block ngay các giao dịch bất thường nếu quá thời gian
    app.use(
      require("./block-fail-api")(failClient, this.failCfg, MAX_BLOCK_INTERVAL)
    );

    // ------------------------route cho API chính thức------------------------- //
    // CÁC API Chính thức của ứng dụng, tùy vào các ứng dụng khác nhau mà khai báo các routes khác nhau
    if (this.apiRoutes) this.apiRoutes(app, this.SUB_DIR);

    // ------------------------Nếu không tìm thấy route thì trả về mặt định------------------------- //
    //ham tra loi cac dia chi khong co
    //The 404 Route (ALWAYS Keep this as the last route)
    app.all("*", (req, res) => {
      // ghi log truy cập kiểu hacker vì không khai báo function ở đây
      // ghi log truy cập bị lỗi cấm api chèn ở đây nếu có hàm req.logAccess được thiết lập
      if (typeof req.logAccess === "function") {
        try {
          // lưu log truy cập fail
          req.logAccess("HACKER", req);
        } catch { }
      }

      //gui trang thai bao noi dung tra ve
      if (req.paramS.redirect) {
        res.writeHead(404, { "Content-Type": "text/html; charset=utf-8" });
        res.end(
          this.CFG.default404Page ||
          `<h1>This is Express Nodejs</h1>
                        <p>Use libarary in <a href="https://www.npmjs.com/package/cng-node-js-utils">cng-node-js-utils<a></p>
                        <p>Your ip is : ${req.clientIp}</p>
                        <p>Your device is : ${req.clientDevice}</p>
                        <p>Author: cuongdq3500888@gmail.com<p>`
        );
      } else {
        // thống kê địa chỉ ip dạng hacker cố tình gửi các link không có để đưa vào diện block.
        console.log(
          arrObj.getTimestamp(),
          "***Hacker--->",
          req.clientIp,
          req.clientDevice,
          req.origin,
          req.url
        );
        // nếu trong vòng 5 giây mà có ít nhất 2 phiên có địa chỉ ip nghi ngờ này thì block luôn địa chỉ ip
        let failAccess = failClient.get(req.clientIp);
        if (!failAccess) {
          failClient.set(req.clientIp, {
            countAll: 1,
            countInteval: 1,
            start: Date.now(),
            time: Date.now(),
          });
        } else {
          failClient.set(req.clientIp, {
            countAll: failAccess.count + 1,
            countInteval:
              Date.now() - failAccess.time >= this.failCfg.checkInterval
                ? 1
                : failAccess.countInteval + 1,
            start: failAccess.start,
            time: Date.now(),
          });
        }

        res.redirect(
          `${this.REDIRECT_URL}?redirect=${encodeURIComponent(req.url)}`
        );
      }
    });

    // --------Nếu lỗi không được xử lý thì trả về nội dung lỗi-------------- //
    //cac route truoc chi can throw, thi error nay se tra loi cho nguoi sdung
    //Error handle ALLWAYS keep last route even all
    app.use(errors);
    // --------------------------------------------------------------------- //

    if (!this.CFG.https) {
      // For http
      const httpServer = require("http").createServer(app);
      // socketIo for http
      if (this.socketIoCfg && this.socketIoCfg.SocketEventHandler && this.socketIoCfg.socketCfg)
        new this.socketIoCfg.SocketEventHandler(
          this.socketIoCfg.socketIo(httpServer, {
            path: `${this.socketIoCfg.socketCfg.base_directory}/socket.io`, // đường dẫn live không trùng với express nhé
            cors: {
              origin: this.socketIoCfg.socketCfg.origin,
            },
          }),
          this.socketIoCfg.socketCfg.is_debug
        );
      httpServer.listen(this.PORT, () => {
        console.log(`Server START in HTTP (${os.platform()};${os.arch()}) is started with:
                - PORT: ${this.PORT} 
                - TEMP DIR: ${os.tmpdir()}  
                - START TIME: ${arrObj.getTimestamp()}`);
      });

    }

    if (this.CFG.isHttps) {
      // For https
      const privateKey = fs.readFileSync(this.CFG.privateKey, "utf8");
      const certificate = fs.readFileSync(this.CFG.certificate, "utf8");
      const credentials = {
        key: privateKey,
        cert: certificate,
        honorCipherOrder: true,
        ciphers: [
          "ECDHE-RSA-AES128-GCM-SHA256",
          "ECDHE-ECDSA-AES128-GCM-SHA256",
          "ECDHE-RSA-AES256-GCM-SHA384",
          "ECDHE-ECDSA-AES256-GCM-SHA384",
          "DHE-RSA-AES128-GCM-SHA256",
          "ECDHE-RSA-AES128-SHA256",
          "DHE-RSA-AES128-SHA256",
          "ECDHE-RSA-AES256-SHA384",
          "DHE-RSA-AES256-SHA384",
          "ECDHE-RSA-AES256-SHA256",
          "DHE-RSA-AES256-SHA256",
          "HIGH",
          "!aNULL",
          "!eNULL",
          "!EXPORT",
          "!DES",
          "!RC4",
          "!MD5",
          "!PSK",
          "!SRP",
          "!CAMELLIA",
        ].join(":"),
      };

      const httpsServer = require("https").createServer(credentials, app);
      // socketIo for https
      if (this.socketIoCfg && this.socketIoCfg.SocketEventHandler && this.socketIoCfg.socketCfg)
        new this.socketIoCfg.SocketEventHandler(
          this.socketIoCfg.socketIo(httpServer, {
            path: `${this.socketIoCfg.socketCfg.base_directory}/socket.io`, // đường dẫn live không trùng với express nhé
            cors: {
              origin: this.socketIoCfg.socketCfg.origin,
            },
          }),
          this.socketIoCfg.socketCfg.is_debug
        );
      httpsServer.listen(this.PORT, () => {
        console.log(`Server START in HTTPS (${os.platform()};${os.arch()}) is started with:
                - PORT: ${this.PORT} 
                - TEMP DIR: ${os.tmpdir()}  
                - START TIME: ${arrObj.getTimestamp()}`);
      });
    }
  }
}

module.exports = ExpressServer;
